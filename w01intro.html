<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Marcin Benke" />
  <title>Programowanie Funkcyjne</title>
  <style type="text/css">
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    /* CSS for syntax highlighting */
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="https://www.w3.org/Talks/Tools/Slidy2/styles/slidy.css" />
  <script
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"
  type="text/javascript"></script>
  <script src="https://www.w3.org/Talks/Tools/Slidy2/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Programowanie Funkcyjne</h1>
  <p class="subtitle">Poznajemy Haskell</p>
  <p class="author">
Marcin Benke
  </p>
  <p class="date">WykÅ‚ad 1, 23.02.2026</p>
</div>
<div id="obietnica" class="title-slide slide section level1">
<h1>Obietnica</h1>
<blockquote>
<p>Lisp is worth learning for [â€¦] the profound enlightenment experience
you will have when you finally get it.<br/> That experience will make
you a better programmer for the rest of your days,even if you never
actually use Lisp [â€¦]<br/> the same can be said of Haskell, and for very
similar reasons.</p>
</blockquote>
<p>â€” Eric S. Raymond, <em>How to Become a Hacker</em></p>
<ul>
<li></li>
</ul>
<blockquote>
<p>Hereâ€™s my recipe for programming success: [â€¦] learn at least a half
dozen programming languages.<br/ > Include one [â€¦] that emphasizes
functional abstraction (like Lisp or ML or Haskell).</p>
</blockquote>
<p>â€” Peter Norvig <em>Teach Yourself Programming in Ten Years</em></p>
<ul>
<li></li>
</ul>
<p>Ten przedmiot da uczestnikom nowe spojrzenie na programowanie i
uczyni ich lepszymi programistami.<br/></p>
<p>OczywiÅ›cie wymaga to zaangaÅ¼owania i wysiÅ‚ku.</p>
</div>
<div id="dlaczego-haskell" class="title-slide slide section level2">
<h1>Dlaczego Haskell?</h1>
<p>Programowanie funkcyjne nie jest juÅ¼ niszÄ… akademickÄ…:</p>
<p><strong>W przemyÅ›le:</strong></p>
<ul>
<li>React/Redux (Facebook) - funkcyjne zarzÄ…dzanie stanem</li>
<li>WhatsApp - Erlang (funkcyjny) obsÅ‚uguje miliardy wiadomoÅ›ci</li>
<li>Jane Street - trading wysokich czÄ™stotliwoÅ›ci w OCaml</li>
<li>Shopify - przetwarzanie zamÃ³wieÅ„ w Elixirze</li>
<li>Blockchain/Smart contracts (Ethereum: Core Solidity, Plutus dla
Cardano)</li>
</ul>
<p><strong>UmiejÄ™tnoÅ›ci transferowalne:</strong></p>
<ul>
<li>MyÅ›lenie deklaratywne</li>
<li>Niemutowalne struktury danych</li>
<li>KompozycjonalnoÅ›Ä‡</li>
</ul>
<p>Wiele jÄ™zykÃ³w imperatywnych wÅ‚Ä…cza elementy funkcyjne</p>
</div>

<div id="trochÄ™-historii" class="title-slide slide section level2">
<h1>TrochÄ™ Historii</h1>
<p>ChociaÅ¼ programowanie funkcyjne staÅ‚o siÄ™ na szerszÄ… skalÄ™ popularne
dopiero w tym stuleciu,<br/> to jego korzenie siÄ™gajÄ… stu lat
wstecz:</p>
<ul>
<li>rachunek kombinatorÃ³w (funkcji): SchÃ¶nfinkel 1924, Curry 1929</li>
<li>rachunek lambda (funkcji anonimowych): Church 1930</li>
<li>(moÅ¼na siÄ™gnÄ…Ä‡ dalej, np. Frege 1893)</li>
</ul>
<p>W 1928, jako kontynuacjÄ™ swego sÅ‚ynnego programu, David Hilbert
wysunÄ…Å‚ nastÄ™pujÄ…cy problem:</p>
<blockquote>
<p>Czy istnieje algorytm, ktÃ³ry potrafi odpowiedzieÄ‡, czy dana formuÅ‚a
logiczna (pierwszego rzÄ™du) jest prawdziwa?</p>
</blockquote>
<p>Aby odpowiedzieÄ‡ na to pytanie, potrzebna jest formalizacja pojÄ™cia
â€œalgorytmuâ€ i szerzej â€œobliczalnoÅ›ciâ€. <br /> W latach 1930-tych
zaproponowano dwie takie formalizacje:</p>
<ul>
<li>funkcje obliczalne Alonzo Churcha (1935) oraz</li>
<li>maszyny Turinga (1936).</li>
</ul>
</div>
<div id="das-entscheidungsproblem---stawki-byÅ‚y-wysokie"
class="slide section level3">
<h1>Das Entscheidungsproblem - stawki byÅ‚y wysokie!</h1>
<p>Hilbert zapytaÅ‚: â€œCzy matematyka jest mechaniczna?â€</p>
<p><strong>Gdyby odpowiedÅº byÅ‚a TAK:</strong></p>
<ul>
<li>Wszystkie twierdzenia matematyczne moÅ¼na by udowodniÄ‡
algorytmem</li>
<li>Matematycy staliby siÄ™ zbÄ™dni ğŸ˜±</li>
<li>Maszyny mogÅ‚yby odkrywaÄ‡ wszystkie prawdy matematyczne</li>
</ul>
<p>(czy coÅ› Wam to przypomina?)</p>
<p><strong>Church i Turing pokazali: NIE!</strong></p>
<ul>
<li>IstniejÄ… problemy nierozstrzygalne;</li>
<li>przy okazji zdefiniowali czym jest â€œobliczenieâ€</li>
<li>oraz dali nam dwa fundamentalnie rÃ³Å¼ne modele myÅ›lenia o nim</li>
</ul>
<p><strong>Pytanie do zastanowienia:</strong> GdybyÅ› Å¼yÅ‚ w 1936 i musiaÅ‚
wymyÅ›liÄ‡ â€œco to znaczy obliczaÄ‡â€ - jak byÅ› to zdefiniowaÅ‚? ğŸ¤”</p>
</div>
<div id="podejÅ›cia-churcha-i-turinga" class="slide section level3">
<h1>PodejÅ›cia Churcha i Turinga</h1>
<p>Dlaczego wszyscy znajÄ… Turinga a maÅ‚o kto Churcha?</p>
<ul>
<li>Maszyna Turinga byÅ‚a bliska Ã³wczesnemu rozumieniu maszyn
liczÄ…cych;</li>
<li>maszynÄ™ w ktÃ³rej krok obliczenia modyfikuje komÃ³rkÄ™ pamiÄ™ci Å‚atwo
zrealizowac sprzÄ™towo.</li>
<li>Åatwiej jÄ… teÅ¼ zrozumieÄ‡ na niskim poziomie (poszczegÃ³lnych
krokÃ³w);</li>
<li>trudniej jednak ogarnÄ…Ä‡ w caÅ‚oÅ›ci jak dziaÅ‚a dana maszyna.</li>
</ul>
</div>
<div id="maszyna-turinga" class="slide section level3">
<h1>Maszyna Turinga</h1>
<p><span class="math inline">\(M= \langle Q, \Gamma, B, \delta, q_0, F
\rangle\)</span> gdzie:</p>
<ul>
<li>Q jest zbiorem stanÃ³w</li>
<li><span class="math inline">\(\Gamma\)</span> jest alfabetem
taÅ›mowym</li>
<li><span class="math inline">\(B\in \Gamma\)</span> to wyrÃ³Å¼niony
symbol pusty
<!-- - $\Sigma\subseteq\Gamma\setminus \{B\}$ to alfabet wejÅ›ciowy --></li>
<li><span class="math inline">\(q_0\)</span> to stan poczatkowy</li>
<li><span class="math inline">\(\delta: Q\times\Gamma\to
Q\times\Gamma\times\{L,R\}\)</span> to funkcja przejÅ›cia<br/> w
zaleÅ¼noÅ›ci od bieÅ¼Ä…cego stanu i symbolu na taÅ›mie okreÅ›la nowy stan i
symbol oraz w ktÃ³rÄ… stronÄ™ przesuwa siÄ™ gÅ‚owica.</li>
</ul>
</div>
<div id="dodawanie---maszyna-turinga" class="slide section level3">
<h1>Dodawanie - Maszyna Turinga</h1>
<p>Reprezentacja: liczby sÄ… zapisane w postaci ciÄ…gu jedynek
rozdzielonych 0</p>
<p>WejÅ›cie: <span class="math inline">\(B1^m01^nB\)</span></p>
<p>WyjÅ›cie: <span class="math inline">\(B1^{m+n}BB\)</span></p>
<div class="float">
<img
src="https://scanftree.com/automata/images/turing_machine/turing_machine_state_diagram_for_adder.png"
alt="MT dla dodawania" />
<div class="figcaption">MT dla dodawania</div>
</div>
<p>Jak to dziaÅ‚a?</p>
</div>
<div id="dodawanie---maszyna-turinga-intuicja"
class="slide section level3">
<h1>Dodawanie - Maszyna Turinga (intuicja)</h1>
<p><strong>Strategia:</strong> PrzeksztaÅ‚Ä‡ <code>111 0 11</code> â†’
<code>11111</code></p>
<p><strong>Algorytm:</strong></p>
<ol style="list-style-type: decimal">
<li>ZnajdÅº separator (0)</li>
<li>ZastÄ…p go jedynkÄ… â†’ teraz mamy <code>111 1 11</code></li>
<li>IdÅº do koÅ„ca drugiej liczby</li>
<li>UsuÅ„ ostatniÄ… jedynkÄ™ (bo â€œprzesunÄ™liÅ›myâ€ jÄ…)</li>
<li>Wynik: <code>11111</code> = 5</li>
</ol>
<p>ZauwaÅ¼my: to jest <em>bardzo</em> niskopoziomowe</p>
<p><a
href="https://turingmachine.io?import-gist=a8874822513d46b5ac0633fec6df1746">turingmachine.io</a>
<img src="turingmachine-qr.png" /></p>
<p>Ä†wiczenie: stwÃ³rz maszynÄ™ dla mnoÅ¼enia.</p>
</div>
<div id="mnoÅ¼enie---maszyna-turinga" class="slide section level3">
<h1>MnoÅ¼enie - Maszyna Turinga</h1>
<!--
 WejÅ›cie: $B0^mC0^nB$; WyjÅ›cie: $B0^{m*n}B$
![](https://media.geeksforgeeks.org/wp-content/uploads/2222-1.png)
-->
<p>WejÅ›cie: <span class="math inline">\(B1^m01^nB\)</span>; WyjÅ›cie:
<span class="math inline">\(B1^{m*n}B\)</span></p>
<p>turingmachine.io (i poniÅ¼szy screenshot) uÅ¼ywajÄ…<code>|,*</code>
zamiast 1,0</p>
<p><img src="multiplierMT.png" /></p>
</div>
<div id="zagadka" class="slide section level3">
<h1>Zagadka</h1>
<table>
<thead>
<tr>
<th>Stan</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1RB</td>
<td>1LC</td>
</tr>
<tr>
<td>B</td>
<td>1RC</td>
<td>1RB</td>
</tr>
<tr>
<td>C</td>
<td>1RD</td>
<td>0LE</td>
</tr>
<tr>
<td>D</td>
<td>1LA</td>
<td>1LD</td>
</tr>
<tr>
<td>E</td>
<td>HALT</td>
<td>0LA</td>
</tr>
</tbody>
</table>
<p>Co zrobi ta maszyna na pustej taÅ›mie (same 0)?</p>
<p>WskazÃ³wka: 47 176 870</p>
</div>

<div id="zagadka-1" class="title-slide slide section level2">
<h1>Zagadka</h1>
<table>
<thead>
<tr>
<th>Stan</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>1RB</td>
<td>0LD</td>
</tr>
<tr>
<td>B</td>
<td>1RC</td>
<td>0RF</td>
</tr>
<tr>
<td>C</td>
<td>1LC</td>
<td>1LA</td>
</tr>
<tr>
<td>D</td>
<td>0LE</td>
<td>HALT</td>
</tr>
<tr>
<td>E</td>
<td>1LF</td>
<td>0RB</td>
</tr>
<tr>
<td>F</td>
<td>0RC</td>
<td>0RE</td>
</tr>
</tbody>
</table>
<p>Co zrobi ta maszyna na pustej taÅ›mie (same 0)?</p>
<p>WskazÃ³wka: 10^^15</p>
</div>

<div id="problem-z-maszynÄ…-turinga"
class="title-slide slide section level2">
<h1>Problem z maszynÄ… Turinga</h1>
<p><strong>Eksperyment myÅ›lowy:</strong> Napisz MT, ktÃ³ra sprawdza czy
liczba jest pierwsza.</p>
<p>Potrzebujesz:</p>
<ul>
<li>StanÃ³w na pÄ™tlÄ™ zewnÄ™trznÄ… (dzielniki)</li>
<li>StanÃ³w na pÄ™tlÄ™ wewnÄ™trznÄ… (dzielenie)</li>
<li>StanÃ³w na porÃ³wnania</li>
<li>StanÃ³w na kopiowanie liczb w pamiÄ™ciâ€¦</li>
</ul>
<p><strong>Wynik:</strong> Setki stanÃ³w dla prostego algorytmu! ğŸ˜±</p>
<p><strong>Kierunki rozwiÄ…zaÅ„:</strong></p>
<ul>
<li>von Neumann/Princeton: imperatywnie ale na wyÅ¼szym poziomie (C,
Java,Python)</li>
<li>Church: rachunek funkcji (Î», kombinatory)</li>
<li>hybrydowe: funkcyjne na wysokim poziomie, kompilacja na instrukcje
niskiego (Haskell)</li>
</ul>
</div>

<div id="od-turinga-do-churcha---zmiana-perspektywy"
class="title-slide slide section level2">
<h1>Od Turinga do Churchâ€™a - zmiana perspektywy</h1>
<p><strong>Maszyna Turinga (imperatywna):</strong></p>
<pre><code>STAN: A, TAÅšMA: [1,1,0,1,_,_], POZYCJA: 3
  â†“ (wykonaj krok)
STAN: B, TAÅšMA: [1,1,1,1,_,_], POZYCJA: 4
  â†“ (wykonaj krok)
...</code></pre>
<p><strong>Rachunek funkcji (deklaratywna):</strong></p>
<p>â€œ2â€ to operacja zastosowania funkcji dwa razy:</p>
<pre><code>   2 f x = f(f(x))</code></pre>
<p>â€œdodaj 2 i 3â€ to:</p>
<pre><code>   (2+3) f x = 2 f (3 f x)
             = f(f(f(f(f(x)))))
             = 5 f x</code></pre>
<p><strong>Kluczowa rÃ³Å¼nica:</strong></p>
<ul>
<li>MT: <em>jak</em> coÅ› obliczyÄ‡ krok po kroku</li>
<li>Church: <em>czym</em> jest wynik jako przeksztaÅ‚cenie</li>
</ul>
</div>

<div id="arytmetyka---rachunek-funkcji"
class="title-slide slide section level2">
<h1>Arytmetyka - rachunek funkcji</h1>
<p>Podstawowa konstrukcja: zastosowanie funkcji do argumentu -
<code>f(x)</code> albo krÃ³cej: <code>f x</code></p>
<p><strong>Liczby naturalne - idea:</strong> liczba n jest
reprezentowana przez n-krotne powtÃ³rzenie funkcji <span
class="math display">\[ n\ s\ z = s^n z \]</span></p>
<p>np. <span class="math inline">\(2\ s\ z = s(s\ z)\)</span></p>
<p><strong>Inna notacja:</strong> <span class="math inline">\(\lambda
x.e\)</span> (Javascript: <code>(x)=&gt;e</code>)</p>
<p><span class="math display">\[2 = \lambda s.\lambda z.s(s\
z)\]</span></p>
<p><span class="math display">\[2 = \lambda s\ z.s(s\ z)\]</span></p>
<p>Tekstowo:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>two <span class="ot">=</span> \s z <span class="ot">-&gt;</span> s(s z)</span></code></pre></div>
<p>albo</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>two s z <span class="ot">=</span> s(s z)</span></code></pre></div>
<p>W Javascript napisalibyÅ›my</p>
<pre><code>const two = (s, z) =&gt; s(s(z))</code></pre>
</div>

<div id="arytmetyka---mnoÅ¼enie-z-intuicjÄ…"
class="title-slide slide section level2">
<h1>Arytmetyka - mnoÅ¼enie (z intuicjÄ…)</h1>
<p>MnoÅ¼enie: <span class="math inline">\((m * n)\ f\ x = m (n\ f)
x\)</span></p>
<p><strong>Rozbicie na etapy - mnoÅ¼enie 3 Ã— 2:</strong></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="co">-- Chcemy: 3 Ã— 2 = 6</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="co">-- Czyli: zastosuj f szeÅ›Ä‡ razy</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="co">-- Krok 1: Co to znaczy &quot;2&quot;?</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a><span class="dv">2</span> f x <span class="ot">=</span> f (f x)           <span class="co">-- zastosuj f dwa razy</span></span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">-- Krok 2: Co to znaczy &quot;3&quot;?</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="dv">3</span> g y <span class="ot">=</span> g (g (g y))       <span class="co">-- zastosuj g trzy razy</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">-- Krok 3: MnoÅ¼enie</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="dv">3</span> Ã— <span class="dv">2</span> <span class="ot">=</span> Î»f<span class="op">.</span>Î»x<span class="op">.</span> <span class="dv">3</span> (<span class="dv">2</span> f) x</span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>      <span class="ot">=</span> Î»f<span class="op">.</span>Î»x<span class="op">.</span> (<span class="dv">2</span> f) ((<span class="dv">2</span> f) ((<span class="dv">2</span> f) x))</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>      <span class="ot">=</span> Î»f<span class="op">.</span>Î»x<span class="op">.</span> f(f(f(f(f(f(x))))))</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>      <span class="ot">=</span> <span class="dv">6</span></span></code></pre></div>
<p><strong>Intuicja:</strong> â€œ3*2â€ = â€œ3 grupy po 2 aplikacje fâ€ = 6
aplikacji f</p>
<p>(na marginesie: â€œm*nâ€ to zÅ‚oÅ¼enie funkcji m i n)</p>
<p>IdÄ…c dalej tym tropem moÅ¼na zdefiniowaÄ‡ potÄ™gowanie, test na
zero,<br/> rekurencjÄ™ (iteracja jest zakodowana przez same
liczby).<br/></p>
<p>W efekcie moÅ¼emy zdefiniowaÄ‡ kaÅ¼dÄ… funkcjÄ™ obliczalnÄ….</p>
</div>

<div id="kombinatory" class="title-slide slide section level2">
<h1>Kombinatory</h1>
<p>Kombinator to funkcja, ktÃ³ra â€œkombinujeâ€ swoje argumenty, np.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="dt">I</span> x <span class="ot">=</span> x</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>two f x <span class="ot">=</span> f(f x)</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>add m n f x <span class="ot">=</span> m f (n f x)</span></code></pre></div>
<!-- Z kolei `four = add two two` jest kombinatorem o ile `add` i `two` potraktowaÄ‡ jako staÅ‚e (zostaÅ‚y wczeÅ›niej zdefiniowane). -->
<p>Fundamentalne odkryciem SchÃ¶nfinkela byÅ‚o, Å¼e kaÅ¼dy kombinator da siÄ™
wyraziÄ‡ przy pomocy tych dwÃ³ch: ğŸ¤¯</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="dt">S</span> x y z <span class="ot">=</span> x z (y z)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a><span class="dt">K</span> x y <span class="ot">=</span> x</span></code></pre></div>
<p>na przykÅ‚ad</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="dt">I</span> <span class="ot">=</span> <span class="dt">S</span> <span class="dt">K</span> <span class="dt">K</span>              <span class="co">-- S K K z = K z (K z) = z = I z</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>two <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">K</span> <span class="dt">S</span>) <span class="dt">K</span>) <span class="dt">I</span></span></code></pre></div>
<p>oczywiÅ›cie programowanie w ten sposÃ³b jest podobnie niewygodne jak
maszyny Turinga, lepiej</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="dt">B</span> x y z <span class="ot">=</span> x(y z)       <span class="co">-- B = S (K S) K</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>one <span class="ot">=</span> <span class="dt">I</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a><span class="fu">succ</span> <span class="ot">=</span> <span class="dt">S</span> <span class="dt">B</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>add <span class="ot">=</span> <span class="dt">B</span> <span class="dt">S</span> (<span class="dt">B</span> <span class="dt">B</span>)</span></code></pre></div>
<p>â€¦a jeszcze lepiej dopasowaÄ‡ zestaw kombinatorÃ³w do potrzeb.</p>
<p>Uwaga notacyjna: z wielkiej litery piszÄ™ tu kombinatory
â€œhistoryczneâ€. W Haskellu poczet liter ma inne znaczenie.</p>
</div>
<div id="kombinatory-i-ich-argumenty" class="slide section level3">
<h1>Kombinatory i ich argumenty</h1>
<p><strong>K</strong> <em>(Konstanzfunktion, producent funkcji
staÅ‚ych)</em></p>
<pre><code>K x y = x</code></pre>
<ul>
<li><code>K</code> bez argumentÃ³w nie redukuje siÄ™</li>
<li><code>K x</code> - teÅ¼ ma za maÅ‚o argumentÃ³w, ale reprezentuje
funkcjÄ™ staÅ‚Ä… <code>f(y) = x</code></li>
<li><code>K x y = x</code> - dokÅ‚adnie dwa argumenty!</li>
<li><code>K x y z = (K x y) z = x z</code> - dwa pierwsze argumenty
uzyte, reszta zostaje</li>
</ul>
<p><strong>S</strong> <em>(VerSchmelzungsfunktion,
sklejacz/rozdzielacz)</em></p>
<pre><code>S f g x = f x (g x)    -- przekaÅ¼ x zarÃ³wno do f jak i g</code></pre>
<p>PrzykÅ‚ad:</p>
<pre><code>S (+) (*2) 3 = (+) 3 ((*2) 3)
             = 3 + 6
             = 9</code></pre>
<p>W tym sensie S jest rozdzielaczem, SchÃ¶nfinkel widziaÅ‚ sklejenie:
<code>f x(g x) = S f g x</code></p>
</div>
<div id="rachunek-lambda" class="slide section level3">
<h1>Rachunek lambda</h1>
<p>Kombinatory sÄ… funkcjami nazwanymi, podobny efekt moÅ¼na uzyskaÄ‡
uÅ¼ywajÄ…c funkcji anonimowych</p>
<p><span class="math display">\[ M ::= x \mid M(M) \mid \lambda x.M
\]</span></p>
<p>ReguÅ‚a obliczenia (tzw. beta-redukcja):</p>
<p><span class="math display">\[ (\lambda x.M)N \to M[N/x] \]</span>
gdzie <span class="math inline">\(M[N/x]\)</span> oznacza term <span
class="math inline">\(M\)</span>, w ktÃ³rym wolne wystapienia <span
class="math inline">\(x\)</span> zastÄ…piono przez <span
class="math inline">\(N\)</span></p>
<p>na przykÅ‚ad</p>
<p><span class="math display">\[ (\lambda x.\lambda y.x)(\lambda x.x)
\to (\lambda y.x)[(\lambda x.x)/x] = \lambda y.\lambda x. x
\]</span></p>
<p>Uwaga: trzeba pilnowaÄ‡ zmiennych zwiÄ…zanych przez <span
class="math inline">\(\lambda\)</span> i w razie potrzeby zmieniaÄ‡ im
nazwy (tzw. <span class="math inline">\(\alpha\)</span>-konwersja):</p>
<p><span class="math display">\[ (\lambda y.x)[y/x] \stackrel{\alpha}{=}
(\lambda z.x)[y/x] = \lambda z.y \]</span></p>
<p>W Haskellu przewaÅ¼ajÄ… funkcje nazwane, ale moÅ¼emy teÅ¼ uÅ¼ywaÄ‡
anonimowych.</p>
</div>

<div id="programowanie-caÅ‚oÅ›ciowe"
class="title-slide slide section level2">
<h1>Programowanie caÅ‚oÅ›ciowe</h1>
<p>OczywiÅ›cie tak w jÄ™zykach imperatywnych jak i funkcyjnych uÅ¼ywamy
arytmetyki maszynowej.<br /> JÄ™zyki imperatywne bliÅ¼sze sÄ… teÅ¼ modelowi
von Neumanna (adresowalne komÃ³rki pamiÄ™ci zamiast taÅ›my)</p>
<p>Tym niemniej ogÃ³lna zasada pozostaje:</p>
<p><strong>w programowaniu funkcyjnym patrzymy bardziej na caÅ‚e
obliczenie niÅ¼ na poszczegÃ³lne kroki.</strong></p>
<p>Suma i iloczyn listy funkcyjnie:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> fold <span class="dv">0</span> (<span class="op">+</span>) list</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a><span class="fu">product</span> <span class="ot">=</span> fold <span class="dv">1</span> (<span class="op">*</span>) list</span></code></pre></div>
<p>Suma i iloczyn listy imperatywnie:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>  sum <span class="op">+=</span> list<span class="op">-&gt;</span>head<span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>  list <span class="op">=</span> list<span class="op">-&gt;</span>tail<span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a><span class="cf">while</span><span class="op">(</span>list<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>  prod <span class="op">*=</span> list<span class="op">-&gt;</span>head<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>  list <span class="op">=</span> list<span class="op">-&gt;</span>tail<span class="op">;</span></span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Ä†wiczenie:</strong> ile problemÃ³w znajdziesz w powyÅ¼szym
kodzie C/C++?</p>
</div>
<div id="programowanie-caÅ‚oÅ›ciowe---wiÄ™cej-przykÅ‚adÃ³w"
class="slide section level3">
<h1>Programowanie caÅ‚oÅ›ciowe - wiÄ™cej przykÅ‚adÃ³w</h1>
<p><strong>Imperatywnie (myÅ›lenie krok-po-kroku):</strong></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="co"># ZnajdÅº pierwsze 10 liczb parzystych wiÄ™kszych od 100</span></span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="kw">def</span> even_more():</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>    result <span class="op">=</span> []</span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">101</span></span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a>    <span class="cf">while</span> <span class="bu">len</span>(result) <span class="op">&lt;</span> <span class="dv">10</span>:</span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a>        result.append(n)</span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a>    n <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<p><strong>Funkcyjnie (myÅ›lenie deklaratywne):</strong></p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="co">-- &quot;WeÅº liczby od 101, filtruj parzyste, weÅº pierwszych 10&quot;</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>evenMore <span class="ot">=</span> <span class="fu">take</span> <span class="dv">10</span> <span class="op">$</span> <span class="fu">filter</span> <span class="fu">even</span> [<span class="dv">101</span><span class="op">..</span>]</span></code></pre></div>
<p><strong>Co zyskujemy?</strong></p>
<ul>
<li>Kod brzmi jak specyfikacja</li>
<li>Brak niepotrzebnych zmiennych tymczasowych
(<code>result, n</code>)</li>
<li>Åatwo modyfikowaÄ‡ (<code>take 20</code>, <code>odd</code>,
itp.)</li>
<li>MoÅ¼na Å‚atwo wykonaÄ‡ rÃ³wnolegle</li>
<li>Mniej bÅ‚Ä™dÃ³w (brak mutacji stanu)</li>
</ul>
<p><strong>Cena?</strong> - Trzeba myÅ›leÄ‡ inaczej (ale warto! ğŸ’ª)</p>
</div>
<div id="ale-przecieÅ¼-w-pythonie-moÅ¼na" class="slide section level3">
<h1>Ale przecieÅ¼ w Pythonie moÅ¼naâ€¦</h1>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="co">-- &quot;WeÅº liczby od 101, filtruj parzyste, weÅº 10 pierwszych&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="fu">take</span> <span class="dv">10</span> <span class="op">$</span> <span class="fu">filter</span> <span class="fu">even</span> [<span class="dv">101</span><span class="op">..</span>]</span></code></pre></div>
<p>Python ma konstrukcje â€œdeklaratywneâ€ (zapoÅ¼yczone z Haskella), ale
czy to zadziaÅ‚a? â€¦i czy jest tak samo czytelne?</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="bu">list</span>(itertools.islice([x <span class="cf">for</span> x <span class="kw">in</span> itertools.count(<span class="dv">101</span>) <span class="cf">if</span> x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>  ], <span class="dv">0</span>, <span class="dv">10</span>))</span></code></pre></div>
<p>(loop)</p>
<p>A to?</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="bu">list</span>(itertools.islice(<span class="bu">filter</span>(<span class="kw">lambda</span> x: x <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>, itertools.count(<span class="dv">101</span>)), <span class="dv">0</span>, <span class="dv">10</span>))</span></code></pre></div>
<p>a dlaczego nie to?</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="bu">filter</span>(<span class="kw">lambda</span> x: x<span class="op">%</span><span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>, itertools.count(<span class="dv">101</span>))[:<span class="dv">10</span>]</span></code></pre></div>
<p>(crash)</p>
</div>

<div id="instrukcje-i-wyraÅ¼enia"
class="title-slide slide section level2">
<h1>Instrukcje i wyraÅ¼enia</h1>
<p>W programowaniu imperatywnym, tak jak i w maszynach Turinga i von
Neumanna, centralnym pojÄ™ciem jest instrukcja: w jaki sposÃ³b zmieniÄ‡
stan maszyny.</p>
<p>W programowaniu funkcyjnym, centralnym pojÄ™ciem jest wyraÅ¼enie,
opisujÄ…ce pewnÄ… wartoÅ›Ä‡.</p>
<p>WyraÅ¼enia mogÄ… zawieraÄ‡ nazwy dla wartoÅ›ci, potocznie nazywane
zmiennymi.</p>
<p>Uwaga: sÅ‚owo zmienna jest tu uÅ¼yte w znaczeniu matematycznym (jak
â€œfunkcja jednej zmiennejâ€), <br/>a nie znanej z programowania
imperatywnego (jak â€œzwiÄ™ksz wartoÅ›Ä‡ zmiennej o 1â€).</p>
</div>
<div id="zasada-przejrzystoÅ›ci" class="slide section level3">
<h1>Zasada przejrzystoÅ›ci</h1>
<p>WartoÅ›Ä‡ wyraÅ¼enia zaleÅ¼y tylko od wartoÅ›ci jego czÄ™Å›ci
skÅ‚adowych;<br/> zastÄ…pienie czÄ™Å›ci wyraÅ¼enia innym wyraÅ¼eniem o tej
samej wartoÅ›ci daje rÃ³wnowaÅ¼ne wyraÅ¼enie.</p>
<p>Konsekwencja: podwyraÅ¼enia mogÄ… byÄ‡ obliczane w dowolnej kolejnoÅ›ci,
a nawet rÃ³wnolegle.</p>
<p>O wyraÅ¼eniach funkcyjnych moÅ¼emy wnioskowaÄ‡ przy uÅ¼yciu zwykÅ‚ych
reguÅ‚ matematycznych</p>
<p><span class="math display">\[ \forall x .f(x)+f(x) = 2f(x)
\]</span></p>
<p>W jÄ™zykach imperatywnych tak nie jest - wyraÅ¼enia mogÄ… zmieniaÄ‡ stan
maszyny; mÃ³wimy wtedy o efektach ubocznych.</p>
<p>Do kwestii efektÃ³w jeszcze wrÃ³cimy - czasami efekty sÄ… wrÄ™cz poÅ¼Ä…dane
(np. I/O).</p>
</div>
<div id="weryfikacja" class="slide section level3">
<h1>Weryfikacja</h1>
<p>Dzieki zasadzie przejrzystoÅ›ci Å‚atwiej dowodziÄ‡ wÅ‚asnoÅ›ci programÃ³w,
np.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a><span class="fu">filter</span> p <span class="op">.</span> <span class="fu">filter</span> q <span class="ot">=</span> <span class="fu">filter</span> (p <span class="op">&amp;&amp;</span> q)</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a><span class="fu">filter</span> p <span class="op">.</span> <span class="fu">concat</span> <span class="ot">=</span> <span class="fu">concat</span> <span class="op">.</span> <span class="fu">map</span>(<span class="fu">filter</span> p)</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a><span class="fu">filter</span> p (xs <span class="op">++</span> ys) <span class="ot">=</span> <span class="fu">filter</span> p xs <span class="op">++</span> <span class="fu">filter</span> p ys</span></code></pre></div>
<p>a takÅ¼e uÅ¼ywaÄ‡ ich do usprawniania programÃ³w.</p>
</div>


<div id="haskell" class="title-slide slide section level1">
<h1>Haskell</h1>
<p>DziÅ› obejrzymy jÄ™zyk Haskell â€œz lotu ptakaâ€<br/> - pobieÅ¼nie omÃ³wimy
najwaÅ¼niejsze pojÄ™cia i konstrukcje, bÄ™dziemy je rozwijaÄ‡ na kolejnych
wykÅ‚adach.</p>
</div>
<div id="haskell-1" class="title-slide slide section level2">
<h1>Haskell</h1>
<p>Nazwa â€” pochodzi od imienia pioniera rachunku kombinatorÃ³w:
<strong>Haskell Brooks Curry</strong> (1900â€“1982)</p>
<p>Czysty jÄ™zyk funkcyjny</p>
<ul>
<li>Bez efektÃ³w ubocznych (ukrytych)</li>
<li>UÅ‚atwia wnioskowanie o programach</li>
</ul>
<p>Leniwy (dokÅ‚adniej: pobÅ‚aÅ¼liwy, ang. <em>non-strict</em>)</p>
<ul>
<li>WyraÅ¼enia nie sÄ… obliczane wczeÅ›niej niÅ¼ potrzeba</li>
<li>UmoÅ¼liwia programowanie z (potencjalnie) nieskoÅ„czonymi
strukturami</li>
<li>Daje peÅ‚nÄ… kompozycjonalnoÅ›Ä‡
(<code>take 3 . filter good . candidates</code>)</li>
</ul>
<p>Zaprojektowany w latach 1990-tych, od tego czasu do dziÅ› intensywnie
rozwijany<br /> (Haskell Report 1.0 1990; Haskell 98 - 2002; Haskell
2010; oraz de facto GHC2021; GHC2024)</p>
</div>

<div id="struktura-programu" class="title-slide slide section level2">
<h1>Struktura programu</h1>
<ul>
<li>Program w Haskellu skÅ‚ada siÄ™ z <em>moduÅ‚Ã³w</em></li>
<li>ModuÅ‚y zawierajÄ… <em>deklaracje</em></li>
<li>NajwaÅ¼niejszÄ… formÄ… deklaracji sÄ… <em>definicje</em> funkcji</li>
<li>CentralnÄ… rolÄ™ w takich definicjach grajÄ… <em>wyraÅ¼enia</em></li>
</ul>
<p><strong>W Haskellu nie ma instrukcji takich jak znamy z innych
jÄ™zykÃ³w (np. przypisania).</strong></p>
<ul>
<li>oprÃ³cz definicji funkcji takÅ¼e deklaracje typÃ³w, klas, itp.</li>
</ul>
</div>

<div id="interpreter" class="title-slide slide section level2">
<h1>Interpreter</h1>
<p>Haskell jest zasadniczo jÄ™zykiem kompilowanym (podobnie jak C), ale
istnieje teÅ¼ interpreter: <code>ghci</code></p>
<p>W interpreterze moÅ¼emy wczytaÄ‡ plik z definicjami i obliczaÄ‡ wartoÅ›ci
wyraÅ¼eÅ„.</p>
<pre><code>$ ghci
GHCi, version 9.8.4: https://www.haskell.org/ghc/  :? for help

ghci&gt; 2 * 2
4
ghci&gt; :load square.hs
[1 of 1] Compiling Main             ( square.hs, interpreted )
Ok, one module loaded.
ghci&gt; square 3
9</code></pre>
</div>

<div id="kompilator" class="title-slide slide section level2">
<h1>Kompilator</h1>
<p>Program, ktÃ³ry zawiera funkcjÄ™ <code>main</code> moÅ¼emy skompilowaÄ‡
do pliku wykonalnego:</p>
<pre class="shell"><code>$ cat answer.hs
main = print 42

$ ghc answer.hs
[1 of 1] Compiling Main             ( answer.hs, answer.o )
Linking answer ...

$ ./answer
42</code></pre>
</div>
<div id="czy-haskell-jest-wolny" class="slide section level3">
<h1>Czy Haskell jest wolny?</h1>
<p>Czy Haskell jest wolniejszy niÅ¼ C?</p>
<p>Tak ale nie bardzo. 30 lat temu tak byÅ‚o, ale teraz GHC jest bardzo
dobrym kompilatorem.</p>
<p>PrzykÅ‚ad benchmarku (benchmarksgame-team.pages.debian.net)</p>
<pre><code>binary-trees

source         secs      mem        gz  cpu secs
Rust #5        1.09     198,720     771   3.84
C clang #2     1.66     170,236     816   5.36
Haskell GHC #4 2.06     271,032     807   5.24
Java  #7       2.62   1,803,192     841   8.14
Node.js #6     8.60   1,250,816     752  30.68
Go #2         14.17     624,780     672  56.29
Swift #4      17.49     707,456     772  55.84
Python 3 #4   33.61     276,992     481 121.96</code></pre>
<p>Czy Haskell jest wolniejszy niz Java/Python?</p>
<p>NIE, zwykle jest szybszy :)</p>
</div>
<div id="czy-programowanie-w-haskellu-wymaga-teorii-kategorii"
class="slide section level3">
<h1>Czy programowanie w Haskellu wymaga teorii kategorii?</h1>
<p>W Internecie mozna znaleÅºÄ‡ â€œparagony grozyâ€ typu:</p>
<blockquote>
<p>Costate Comonad Coalgebra is equivalent of Java member variable
update technology for Haskell</p>
</blockquote>
<p><code>- @PLT_Borat</code></p>
<p>albo</p>
<blockquote>
<p>A monad is just a monoid in the category of endofunctors, whatâ€™s the
problem?</p>
</blockquote>
<p>Pewne dziaÅ‚y matematyki sÄ… istotnie przydatne w bardzo zaawansowanym
programowaniu, ale na co dzieÅ„ nie sa potrzebne.</p>
<p>Haskell jest oczywiÅ›cie zupeÅ‚nie inny niÅ¼ np. Java, ale przekonamy
siÄ™, Å¼e nie jest trudniejszy niÅ¼ dajmy na to C++:</p>
<blockquote>
<p>The lambda expression is a prvalue expression of unique unnamed
non-union non-aggregate class type, known as closure type, which is
declared (for the purposes of ADL) in the smallest [â€¦] scope that
contains the lambda expression.</p>
</blockquote>
<blockquote>
<p>A prvalue is an expression whose evaluation computes the value of an
operand of a built-in operator, or initializes an object.</p>
</blockquote>
<blockquote>
<p>[cppreference.com]</p>
</blockquote>
</div>

<div id="uÅ¼ycie-funkcji" class="title-slide slide section level2">
<h1>UÅ¼ycie funkcji</h1>
<p>PodstawowÄ… rzeczÄ…, ktÃ³rÄ… moÅ¼emy zrobiÄ‡ z funkcjÄ…, jest wyznaczenie
jej wartoÅ›ci dla danych argumentÃ³w;<br/> mÃ³wimy wtedy o zastosowaniu
(aplikacji) funkcji do argumentÃ³w.</p>
<p>(za chwilÄ™ przekonamy siÄ™ dlaczego nie mÃ³wimy o wywoÅ‚aniu
funkcji).</p>
<pre><code>ghci&gt; not True
False
ghci&gt; min 2 3
2</code></pre>
<p>zauwaÅ¼my, Å¼e piszemy raczej <code>f x y</code> niÅ¼
<code>f(x,y)</code> - pÃ³Åºniej wyjaÅ›nimy dlaczego.</p>
<p>OczywiÅ›cie funkcje mogÄ… byÄ‡ argumentami i wynikami innych
funkcji.</p>
<p>Funkcje sÄ… wartoÅ›ciami podobnie jak liczby, jednak (w ogÃ³lnoÅ›ci) nie
moÅ¼emy ich wypisaÄ‡.</p>
</div>

<div id="funkcje-i-definicje" class="title-slide slide section level2">
<h1>Funkcje i definicje</h1>
<p>Definicja funkcji mÃ³wi, jaka jest jej wartoÅ›Ä‡ dla danych
argumentÃ³w:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>square x <span class="ot">=</span> x <span class="op">*</span> x</span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>twice f x <span class="ot">=</span> f(f x)</span></code></pre></div>
<p>Samo zastosowanie funkcji nie wymaga nawiasÃ³w, ale sÄ… one potrzebne
jeÅ›li argument jest wyraÅ¼eniem zÅ‚oÅ¼onym.</p>
<p>MoÅ¼emy definiowaÄ‡ â€œfunkcje 0-argumentoweâ€, czyli staÅ‚e:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a>answer <span class="ot">=</span> <span class="dv">40</span> <span class="op">+</span> <span class="dv">2</span></span></code></pre></div>
<p>Definicje zapisujemy w pliku, ktÃ³ry moÅ¼emy zaÅ‚adowaÄ‡ do interpretera
lub skompilowaÄ‡.</p>
<p>W interpreterze moÅ¼na tworzyÄ‡ proste (zasadniczo jednolinijkowe)
definicje ad-hoc, ale nie jest to zalecane.</p>
</div>
<div id="formy-definicji" class="slide section level3">
<h1>Formy definicji</h1>
<p>Definicja moÅ¼e zawieraÄ‡ warunki (guards):</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>mn x y <span class="op">|</span> x <span class="op">&lt;</span>  y <span class="ot">=</span> x</span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a>       <span class="op">|</span> x <span class="op">&gt;=</span> y <span class="ot">=</span> y</span></code></pre></div>
<p>moÅ¼e teÅ¼ zawieraÄ‡ definicje pomocnicze</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" tabindex="-1"></a>f x y <span class="op">|</span> x <span class="op">&lt;</span> a     <span class="ot">=</span> x <span class="op">+</span> a</span>
<span id="cb31-2"><a href="#cb31-2" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> x <span class="op">-</span> a       <span class="co">-- warunki sÄ… sprawdzane kolejno, pierwszy speÅ‚niony wygrywa</span></span>
<span id="cb31-3"><a href="#cb31-3" tabindex="-1"></a>      <span class="kw">where</span></span>
<span id="cb31-4"><a href="#cb31-4" tabindex="-1"></a>        a <span class="ot">=</span> square(y<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb31-5"><a href="#cb31-5" tabindex="-1"></a>        square x <span class="ot">=</span> x <span class="op">*</span> x</span></code></pre></div>
<p>NB zasiÄ™giem definicji w <code>where</code> sÄ… wszystkie gaÅ‚Ä™zie
warunkowe.</p>
</div>

<div id="rekurencja" class="title-slide slide section level2">
<h1>Rekurencja</h1>
<p>Definicje mogÄ… byÄ‡ rekurencyjne</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>fact n <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb32-2"><a href="#cb32-2" tabindex="-1"></a>       <span class="op">|</span> n <span class="op">&gt;</span>  <span class="dv">1</span> <span class="ot">=</span>  n <span class="op">*</span> fact(n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>W programowaniu funkcyjnym rekurencja jest podstawowym mechanizmem
sterowania (nie ma instrukcji, zatem nie ma <code>while</code>).</p>
<p>Definicje mogÄ… byÄ‡ wzajemnie rekurencyjne, dlatego moÅ¼emy je pisaÄ‡ w
dowolnej kolejnoÅ›ci.</p>
</div>

<div id="obliczenia" class="title-slide slide section level2">
<h1>Obliczenia</h1>
<p>Obliczenie wartoÅ›ci wyraÅ¼enia polega na redukowaniu (upraszczaniu)
wyraÅ¼enia aÅ¼ do uzyskania postaci kanonicznej.</p>
<pre><code>square x = x * x</code></pre>
<p>SpÃ³jrzmy na wyraÅ¼enie <code>square(3+4)</code>; jedna z moÅ¼liwych
redukcji</p>
<pre><code>square (3+4) = { + }
square 7     = { square }
7 * 7        = { * }
49</code></pre>
<p>WyraÅ¼enie â€œ49â€ nie da siÄ™ zredukowaÄ‡ - jest ono wartoÅ›ciÄ… (jest w
postaci normalnej).</p>
</div>

<div id="kolejnoÅ›Ä‡-ewaluacji" class="title-slide slide section level2">
<h1>KolejnoÅ›Ä‡ ewaluacji</h1>
<p>Dla wiÄ™kszoÅ›ci wyraÅ¼eÅ„ moÅ¼liwe sÄ… rÃ³Å¼ne kolejnoÅ›ci obliczeÅ„.</p>
<p>InnÄ… moÅ¼liwoÅ›ciÄ… obliczenia <code>square(3+4)</code> jest</p>
<pre><code>square (3+4)  = { square }
(3+4) * (3+4) = { + }
7 * 7         = { * }
49</code></pre>
<p>WiÄ™kszoÅ›Ä‡ jÄ™zykÃ³w oblicza wartoÅ›ci argumentÃ³w przed przekazaniem ich
do funkcji; <br /> kolejnoÅ›Ä‡ obliczania skÅ‚adowych wyraÅ¼enia moÅ¼e mieÄ‡
wpÅ‚yw na jego wartoÅ›Ä‡.</p>
<p>W Haskellu (przejrzystoÅ›Ä‡!), jeÅ›li dwie kolejnoÅ›ci obliczeÅ„ prowadzÄ…
do wyniku, <br /> to dadzÄ… ten sam wynik.</p>
</div>

<div id="kolejnoÅ›Ä‡-ewaluacji-1"
class="title-slide slide section level2">
<h1>KolejnoÅ›Ä‡ ewaluacji</h1>
<p>JeÅ›li dwie strategie (kolejnoÅ›ci) obliczeÅ„ prowadzÄ… do wyniku, to
dadzÄ… ten sam wynik.</p>
<p>Natomiast moÅ¼e siÄ™ zdarzyÄ‡, Å¼e niektÃ³re strategie nie prowadzÄ… do
wyniku (bÅ‚Ä…d, zapÄ™tlenie).</p>
<p>Dlatego Haskell nie oblicza wartoÅ›ci argumentÃ³w przed przekazaniem
ich do funkcji <br /> jeÅ¼eli nie jest to niezbÄ™dne.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>ghci<span class="op">&gt;</span> k x y <span class="ot">=</span> x</span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a>ghci<span class="op">&gt;</span> k <span class="st">&quot;OK&quot;</span>  (<span class="fu">error</span> <span class="st">&quot;crash!&quot;</span>)</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a><span class="st">&quot;OK&quot;</span></span></code></pre></div>
<p>Haskell: <strong>OK</strong>; ML, Scala, C: <code>crash!</code></p>
<p>DomyÅ›lna strategia w Haskellu (tzw. strategia normalna) ma tÄ™
wÅ‚asnoÅ›Ä‡, <br /> Å¼e jeÅ›li jakaÅ› strategia obliczeÅ„ prowadzi do wyniku,
to normalna teÅ¼.</p>
<p>Strategia normalna wykonuje najpierw najbardziej zewnÄ™trznÄ… redukcjÄ™
(leftmost-outermost)</p>
</div>

<div id="wartoÅ›Ä‡-nieokreÅ›lona" class="title-slide slide section level2">
<h1>WartoÅ›Ä‡ nieokreÅ›lona</h1>
<p>Obliczenia mogÄ… nie prowadziÄ‡ do wyniku (bÅ‚Ä…d, zapÄ™tlenie).</p>
<p>Aby jednak zachowaÄ‡ zasadÄ™, Å¼e kaÅ¼de poprawne wyraÅ¼enie opisuje jakÄ…Å›
wartoÅ›Ä‡, <br /> czasami wprowadza siÄ™ â€œwartoÅ›Ä‡ nieokreÅ›lonÄ…â€: <span
class="math inline">\(\bot\)</span> (tzw. pinezka, ang.
<em>bottom</em>).</p>
<p>DokÅ‚adniej, wartoÅ›ciÄ… wyraÅ¼enia jest <span
class="math inline">\(\bot\)</span>,<br /> jeÅ›li jego obliczenie w
porzÄ…dku normalnym prowadzi do bÅ‚Ä™du lub zapÄ™tlenia.</p>
<p>W Haskellu takÄ… wartoÅ›Ä‡ majÄ… np</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" tabindex="-1"></a>bottom1 <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb37-2"><a href="#cb37-2" tabindex="-1"></a>bottom2 <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;some message&quot;</span></span>
<span id="cb37-3"><a href="#cb37-3" tabindex="-1"></a>bottom3 <span class="ot">=</span> bottom3</span></code></pre></div>
</div>

<div id="funkcje-rygorystyczne-i-pobÅ‚aÅ¼liwe"
class="title-slide slide section level2">
<h1>Funkcje rygorystyczne i pobÅ‚aÅ¼liwe</h1>
<p>JeÅ›li <span class="math inline">\(f(\bot) = \bot\)</span>, mÃ³wimy Å¼e
funkcja <span class="math inline">\(f\)</span> jest
<em>rygorystyczna</em> albo <em>pedantyczna</em> (ang.
<em>strict</em>).</p>
<p>W przeciwnym wypadku mÃ³wimy, Å¼e jest <em>pobÅ‚aÅ¼liwa</em> (ang.
<em>non-strict</em>).</p>
<p>W wypadku funkcji wieloargumentowej moÅ¼emy mÃ³wiÄ‡, ze funkcja jest
rygorystyczna ze wzglÄ™du na ktÃ³ryÅ› argument.</p>
<p>RozwaÅ¼my na przykÅ‚ad funkcje</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a><span class="fu">const</span> x y <span class="ot">=</span> x</span></code></pre></div>
<p>Funkcja <code>id</code> jest rygorystyczna.</p>
<p>Funkcja <code>const</code> jest rygorystyczna dla pierwszego
argumentu, ale pobÅ‚aÅ¼liwa dla drugiego:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" tabindex="-1"></a><span class="fu">id</span> <span class="fu">undefined</span> <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb39-2"><a href="#cb39-2" tabindex="-1"></a><span class="fu">const</span> <span class="fu">undefined</span> y <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb39-3"><a href="#cb39-3" tabindex="-1"></a><span class="fu">const</span> x <span class="fu">undefined</span> <span class="ot">=</span> x</span></code></pre></div>
<!--
Nie jest jednak w peÅ‚ni rygorystyczna:
$\quad const(\bot) = \lambda y.\bot \neq \bot$
-->
<p>Gorliwa (eager) ewaluacja (najpierw argumenty) daje funkcje
pedantyczne.<br/> Leniwa (lazy) ewaluacja (dopiero kiedy trzeba) pozwala
na funkcje pobÅ‚aÅ¼liwe.</p>
</div>

<div id="listy" class="title-slide slide section level2">
<h1>Listy</h1>
<p>Listy sÄ… popularnÄ… strukturÄ… danych. W Haskellu na tyle waÅ¼nÄ…, Å¼e
bÄ™dzie o nich osobny wykÅ‚ad.</p>
<p>Sposoby tworzenia list:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>]</span>
<span id="cb40-2"><a href="#cb40-2" tabindex="-1"></a>[<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]</span>
<span id="cb40-3"><a href="#cb40-3" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span><span class="op">..</span><span class="dv">9</span>]</span>
<span id="cb40-4"><a href="#cb40-4" tabindex="-1"></a>[<span class="dv">2</span><span class="op">*</span>n<span class="op">+</span><span class="dv">1</span> <span class="op">|</span> n <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]]</span>
<span id="cb40-5"><a href="#cb40-5" tabindex="-1"></a><span class="dv">0</span><span class="op">:</span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]  <span class="co">-- (head:tail)</span></span></code></pre></div>
<p>Napisy sÄ… listami znakÃ³w:</p>
<pre><code>ghci&gt; [&#39;a&#39;..&#39;h&#39;]
&quot;abcdefgh&quot;</code></pre>
<p>Na laboratorium poznamy funkcje na listach takie, jak:</p>
<pre><code>(++),  take,  drop,  concat, reverse, words, unwords, filter, ...</code></pre>
</div>

<div id="strumienie" class="title-slide slide section level2">
<h1>Strumienie</h1>
<p>JednÄ… z ciekawych moÅ¼liwoÅ›ci, jakie daje leniwa ewaluacja jest
programowanie z (potencjalnie) nieskoÅ„czonymi strukturami danych.<br/>
JednÄ… z takich struktur sÄ… strumienie, czyli leniwe listy.</p>
<p>MoÅ¼emy na przykÅ‚ad zdefiniowaÄ‡ strumieÅ„ wszystkich liczb
naturalnych:</p>
<pre><code>&gt; nats = [0..]
&gt; few = take 5   -- weÅº piÄ™Ä‡ pierwszych elementÃ³w
&gt; few nats
[0,1,2,3,4]</code></pre>
<p>Potem moÅ¼emy wybraÄ‡ ze strumienia tylko parzyste:</p>
<pre><code>&gt; evens = [x | x &lt;- nats, even x]
&gt; few evens
[0,2,4,6,8]
&gt; evens !! 444_444
888888

&gt; odds = [x+1 | x &lt;- evens]
&gt; few odds
[1,3,5,7,9]</code></pre>
</div>

<div id="strumienie---ciekawsze-przykÅ‚ady"
class="title-slide slide section level2">
<h1>Strumienie - ciekawsze przykÅ‚ady</h1>
<p>Fibonacci: lista, ktÃ³ra zjada swÃ³j wÅ‚asny ogon</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" tabindex="-1"></a>fibs <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fibs (<span class="fu">tail</span> fibs)</span>
<span id="cb45-2"><a href="#cb45-2" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" tabindex="-1"></a><span class="co">-- WeÅº 10 pierwszych:</span></span>
<span id="cb45-4"><a href="#cb45-4" tabindex="-1"></a><span class="fu">take</span> <span class="dv">10</span> fibs  <span class="co">-- [0,1,1,2,3,5,8,13,21,34]</span></span>
<span id="cb45-5"><a href="#cb45-5" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" tabindex="-1"></a><span class="co">-- 1000-nÄ…:</span></span>
<span id="cb45-7"><a href="#cb45-7" tabindex="-1"></a>fibs <span class="op">!!</span> <span class="dv">1000</span>  <span class="co">-- obliczone natychmiast!</span></span></code></pre></div>
<p>Liczby pierwsze:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>sieve (p<span class="op">:</span>xs) <span class="ot">=</span> p <span class="op">:</span> sieve [x <span class="op">|</span> x <span class="ot">&lt;-</span> xs, x <span class="ot">`mod`</span> p <span class="op">/=</span> <span class="dv">0</span>]</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a>primes <span class="ot">=</span> sieve [<span class="dv">2</span><span class="op">..</span>]</span>
<span id="cb46-3"><a href="#cb46-3" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" tabindex="-1"></a><span class="fu">take</span> <span class="dv">10</span> primes  <span class="co">-- [2,3,5,7,11,13,17,19,23,29]</span></span></code></pre></div>
</div>

<div id="typy" class="title-slide slide section level2">
<h1>Typy</h1>
<p>KaÅ¼de (poprawne) wyraÅ¼enie ma typ. <br /> Typ wartoÅ›ci jest pewnÄ…
klasÄ… abstrakcji: <br /> wskazuje wÅ‚asnoÅ›ci wspÃ³lne dla wartoÅ›ci tego
typu.</p>
<p>Na najniÅ¼szym poziomie, komputery operujÄ… na ciÄ…gach bitÃ³w. <br />
System typÃ³w pozwala na tworzenie abstrakcji - nadaje nowe znaczenia
ciÄ…gom bitÃ³w <br /> (to jest adres, to jest liczba, to jest numer
rezerwacji).</p>
<p>Haskell ma <em>silne typowanie</em> - typy nie zmieniajÄ… siÄ™ w
trakcie obliczeÅ„ (nie ma rzutowaÅ„).</p>
<p>Typy sÄ… wyprowadzalne - interpreter/kompilator potrafi odtworzyÄ‡ typ
dowolnego wyraÅ¼enia. <br /> W zwiazku z tym deklarowanie typÃ³w funkcji
nie jest obowiÄ…zkowe, ale jest uÅ¼ytecznÄ… dokumentacjÄ… (sprawdzanÄ… przez
kompilator!)</p>
<p>W ghci moÅ¼emy zapytaÄ‡ o typ dowolnego wyraÅ¼enia</p>
<pre><code>ghci&gt; :type words &quot;a b c&quot;
words &quot;a b c&quot; :: [String]
ghci&gt; :t words
words :: String -&gt; [String]
ghci&gt; :type (+)
(+) :: Num a =&gt; a -&gt; a -&gt; a
ghci&gt; :type +d (+)
(+) :: Integer -&gt; Integer -&gt; Integer</code></pre>
</div>
<div id="dlaczego-typy-praktycznie" class="slide section level3">
<h1>Dlaczego typy? (praktycznie)</h1>
<p><strong>Typy = automatyczna dokumentacja + weryfikacja</strong></p>
<p>Bez typÃ³w (Python/JavaScript):</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a><span class="kw">def</span> process(data, config, debug):</span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>    <span class="co"># Co to jest data? Lista? Dict? String?</span></span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a>    <span class="co"># Co to jest config? Opcjonalny?</span></span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a>    <span class="co"># debug to bool? String? Int (0/1)?</span></span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a>    ...</span></code></pre></div>
<p><strong>Z typami (Haskell):</strong></p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Debug</span> <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a><span class="ot">process ::</span> [<span class="dt">User</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Config</span> <span class="ot">-&gt;</span> <span class="dt">Debug</span> <span class="ot">-&gt;</span> <span class="dt">Result</span></span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a><span class="co">--           â†‘           â†‘             â†‘         â†‘</span></span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a><span class="co">--         lista     moÅ¼e byÄ‡       True/False  zwraca</span></span>
<span id="cb49-5"><a href="#cb49-5" tabindex="-1"></a><span class="co">--         userÃ³w    niezdefiniowane            Result</span></span></code></pre></div>
<p><strong>KorzyÅ›ci:</strong></p>
<ul>
<li>âœ“ <strong>IDE wie</strong> co moÅ¼na zrobiÄ‡ z argumentami</li>
<li>âœ“ <strong>Kompilator wykryje</strong> bÅ‚Ä™dy PRZED uruchomieniem</li>
<li>âœ“ <strong>Kolega z zespoÅ‚u wie</strong> jak uÅ¼yÄ‡ funkcji</li>
<li>âœ“ <strong>Refactoring jest bezpieczny</strong> (zmiana typu â†’
wszystkie uÅ¼ycia muszÄ… siÄ™ zgadzaÄ‡)</li>
</ul>
</div>
<div id="przykÅ‚ad-z-Å¼ycia" class="slide section level3">
<h1>PrzykÅ‚ad z Å¼ycia:</h1>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="co">-- Ta funkcja NIE SKOMPILUJE SIÄ˜ jeÅ›li zwrÃ³ci Nothing</span></span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a><span class="ot">getUserEmail ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">Email</span>  <span class="co">-- MUSI zwrÃ³ciÄ‡ Email</span></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a><span class="co">-- Ta funkcja moÅ¼e nie znaleÅºÄ‡ uÅ¼ytkownika</span></span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a><span class="ot">findUser ::</span> <span class="dt">UserId</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">User</span>  <span class="co">-- Jasno komunikuje: moÅ¼e byÄ‡ Nothing</span></span></code></pre></div>
</div>

<div id="typy-funkcji" class="title-slide slide section level2">
<h1>Typy funkcji</h1>
<p>Argumenty do funkcji przekazujemy â€œpo jednymâ€, na przykÅ‚ad
<code>mn x y</code>.<br/> W wyraÅ¼eniu <code>f(x,y)</code> argumentem
funkcji <code>f</code> jest para <code>(x,y)</code>. <br/> OczywiÅ›cie
krotki mogÄ… byÄ‡ argumentami funkcji, ale pamiÄ™tajmy, Å¼e
<code>f(x,y)</code> to nie to samo co <code>f x y</code></p>
<p>Znajduje to odbicie w typach funkcyjnych</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a><span class="ot">mn ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>Typ <code>Int -&gt; Int -&gt; Int</code> jest rÃ³wnowaÅ¼ny
<code>Int -&gt; (Int -&gt; Int)</code> <br /> i oznacza funkcjÄ™, ktÃ³ra
dostawszy argument typu <code>Int</code> daje w wyniku funkcjÄ™
<code>Int -&gt; Int</code>.</p>
<p>Z kolei <code>(Int -&gt; Int) -&gt; Int</code> to typ funkcji, ktÃ³rej
argumentami sÄ… funkcje <code>Int -&gt; Int</code>.</p>
<p>Analogicznie <code>mn x y</code> jest rÃ³wnowaÅ¼ne
<code>(mn x) y</code> ale czym innym niÅ¼ <code>mn(x y)</code>!</p>
<p>Tym niemniej potocznie mÃ³wimy Å¼e funkcja jest n-argumentowaâ€.<br/> W
rzeczywistosci redukcja aplikacji odbywa siÄ™ tylko gdy jest odpowiednia
liczba argumentÃ³w. <br/> (czyli w naszym przykÅ‚adzie <code>mn 0</code>
siÄ™ nie redukuje, dopiero <code>mn 0 3</code>)</p>
</div>

<div id="typy-polimorficzne" class="title-slide slide section level2">
<h1>Typy polimorficzne</h1>
<p>NiektÃ³re funkcje mogÄ… dziaÅ‚aÄ‡ dla argumentÃ³w rÃ³Å¼nych typÃ³w - czyli
mogÄ… mieÄ‡ wiÄ™cej niÅ¼ jeden typ; na przykÅ‚ad identycznoÅ›Ä‡</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>wyrazamy to przy pomocy tzw. zmiennych typowych</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>NaleÅ¼y to rozumieÄ‡ tak, Å¼e identycznoÅ›Ä‡ ma typ <code>a -&gt; a</code>
dla dowolnego typu <code>a</code>.</p>
<p>WartoÅ›Ä‡ nieokreÅ›lona i bÅ‚Ä…d sÄ… dowolnego typu:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="fu">undefined</span><span class="ot"> ::</span> a</span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a><span class="fu">error</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p><strong>Uwaga:</strong> <code>undefined</code> to coÅ› caÅ‚kiem innego
niÅ¼ w Javascript, mniej wiÄ™cej</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" tabindex="-1"></a><span class="fu">undefined</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;undefined&quot;</span></span></code></pre></div>
</div>

<div id="definiowanie-typÃ³w" class="title-slide slide section level2">
<h1>Definiowanie typÃ³w</h1>
<p>MoÅ¼emy definiowaÄ‡ wÅ‚asne typy danych, np.:</p>
<ul>
<li><code>data Color = Red | Green | Blue</code></li>
<li><code>data ExitCode = ExitSuccess | ExitFailure Int</code></li>
</ul>
<p>Typy mogÄ… byÄ‡ rekurencyjne</p>
<ul>
<li><code>data Nat = Zero | Succ Nat</code></li>
</ul>
<p>â€¦ i polimorficzne</p>
<ul>
<li><code>data Maybe a = Nothing | Just a</code></li>
<li><code>data Tree a = Empty | Node a (Tree a) (Tree a)</code></li>
</ul>
<p>Funkcje operujÄ…ce na takich typach moÅ¼emy definiowaÄ‡ przez przypadki
(dopasowanie wzorca)</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a>add m <span class="dt">Zero</span> <span class="ot">=</span> m</span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>add m (<span class="dt">S</span> n) <span class="ot">=</span> <span class="dt">S</span> (add m n)</span></code></pre></div>
<p>Typom poÅ›wiÄ™cony bÄ™dzie nastÄ™pny wykÅ‚ad.</p>
</div>

<div id="klasy-typÃ³w" class="title-slide slide section level2">
<h1>Klasy typÃ³w</h1>
<p>Czasami jakaÅ› operacja ma sens dla wiÄ™cej niÅ¼ jednego typu;<br /> np.
dodawanie dla <code>Int</code>, <code>Double</code> itp.</p>
<p>W Haskellu jest to zrealizowane przy pomocy <em>klas typÃ³w</em><br/>
- zbiorÃ³w typÃ³w, ktÃ³re majÄ… wspÃ³lny interfejs (ale byÄ‡ moÅ¼e zupeÅ‚nie
inne implementacje).</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="ot">(+) ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Rozumiemy to tak, Å¼e dodawanie jest przeciÄ…Å¼one i ma typ
<code>a -&gt; a -&gt; a</code> dla dowolnego typu <code>a</code>
naleÅ¼acego do klasy <code>Num</code><br/> (czyli realizujÄ…cego interfejs
<code>Num</code>).</p>
<p>TakÅ¼e literaÅ‚y liczbowe sÄ… przeciÄ…Å¼one</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a><span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a><span class="fl">3.14</span><span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<p>Klasy typÃ³w omÃ³wimy dogÅ‚Ä™bnie na jednym z kolejnych wykÅ‚adÃ³w.</p>
</div>

<div id="przejrzystoÅ›Ä‡" class="title-slide slide section level2">
<h1>PrzejrzystoÅ›Ä‡</h1>
<p>Haskell jest jÄ™zykiem czystym, w ktÃ³rym obowiÄ…zuje zasada
przejrzystoÅ›ci:</p>
<ul>
<li>kaÅ¼de obliczenie wyraÅ¼enia daje ten sam wynik</li>
<li>zastÄ…pienie wyraÅ¼enia innym wyraÅ¼eniem o tej samej wartoÅ›ci daje
rÃ³wnowaÅ¼ny program</li>
</ul>
<p>Na przykÅ‚ad</p>
<ul>
<li><code>let x = 2 in x+x</code> jest rÃ³wnowaÅ¼ne <code>2+2</code></li>
<li><code>let f x = x + x in f 2</code> jest rÃ³wnowaÅ¼ne
<code>2+2</code></li>
<li><code>let x = g 2 in x + x</code> jest rÃ³wnowaÅ¼ne
<code>g 2 + g 2</code> dla dowolnej funkcji g (odpowiedniego typu).</li>
</ul>
</div>
<div id="efekty-uboczne" class="slide section level3">
<h1>Efekty uboczne</h1>
<p>Sytuacja komplikuje siÄ™ w obecnoÅ›ci efektÃ³w ubocznych, np. I/O. <br/>
Powiedzmy, Å¼e mamy funkcjÄ™ <code>readInt :: Handle -&gt; Int</code>
wczytujÄ…cÄ… liczbÄ™ ze strumienia (np. <code>stdin</code>). Czy</p>
<pre><code>let x = readInt stdin in x+x</code></pre>
<p>jest rÃ³wnowaÅ¼ne <code>readInt stdin + readInt stdin</code> ?</p>
<p>Efekty uboczne sÄ… w konflikcie z zasadÄ… przejrzystoÅ›ci. <br/> RÃ³Å¼ne
jÄ™zyki rozwiÄ…zujÄ… to na rÃ³Å¼ne sposoby, z reguÅ‚y rezygnujÄ…c z
przejrzystoÅ›ci. <br/> W ML niektÃ³re funkcje nie sÄ… przejrzyste. W C
prawie Å¼adne funkcje nie sÄ… przejrzyste.</p>
</div>
<div id="czystoÅ›Ä‡-jest-bliska-boskoÅ›ci" class="slide section level3">
<h1>CzystoÅ›Ä‡ jest bliska boskoÅ›ci</h1>
<p>W Haskellu przejrzystoÅ›Ä‡ jest zasadÄ… nadrzÄ™dnÄ…, dlatego<br />
<strong>nie moÅ¼e</strong> byÄ‡ funkcji takiej jak
<code>readInt :: Handle -&gt; Int</code>.<br /></p>
<p>Funkcja speÅ‚niajÄ…ca podobnÄ… rolÄ™ bÄ™dzie miaÅ‚a typ
<code>Handle -&gt; IO Int</code>.</p>
<p>RÃ³Å¼nica wydaje siÄ™ kosmetyczna, ale jest w istocie fundamentalna:</p>
<ul>
<li>wyraÅ¼enie <code>readInt stdin</code> nie daje teraz wartoÅ›ci typu
Int, ale <strong>obliczenie</strong>,<br /> ktÃ³rego wykonanie da wartoÅ›Ä‡
typu <code>Int</code> (przepis na uzyskanie wartoÅ›ci typu
<code>Int</code>);</li>
<li>dziÄ™ki temu zachowujemy przejrzystoÅ›Ä‡ - kaÅ¼de wywoÅ‚anie da takie
samo obliczenie (wczytaj liczbÄ™ z stdin).</li>
<li>system wykonawczy uruchamia obliczenie stanowiÄ…ce wartoÅ›Ä‡ funkcji
<code>main</code></li>
</ul>
<div class="sourceCode" id="cb60"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>k x y <span class="ot">=</span> x</span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>main <span class="ot">=</span> k (<span class="fu">print</span> <span class="st">&quot;foo&quot;</span>) (<span class="fu">print</span> <span class="st">&quot;bar&quot;</span>)</span></code></pre></div>
</div>


<div id="podsumowanie" class="title-slide slide section level1">
<h1>Podsumowanie</h1>
<ul>
<li>Programowanie funkcyjne opiera siÄ™ na innym sposobie rozumienia
obliczeÅ„</li>
<li>Rachunek funkcji zamiast maszyny stanowej</li>
<li>Haskell - czysty jÄ™zyk funkcyjny</li>
<li>Zasada przejrzystoÅ›ci:
<ul>
<li>wartoÅ›Ä‡ wyraÅ¼enia zaleÅ¼y tylko od wartoÅ›ci jego czÄ™Å›ci
skÅ‚adowych;</li>
<li>zastÄ…pienie czÄ™Å›ci wyraÅ¼enia innym wyraÅ¼eniem o tej samej wartoÅ›ci
daje rÃ³wnowaÅ¼ne wyraÅ¼enie;</li>
<li>uÅ‚atwia caÅ‚oÅ›ciowe patrzenie na programy i wnioskowanie.</li>
</ul></li>
<li>Leniwa ewaluacja:
<ul>
<li>wyraÅ¼enia nie sÄ… obliczane wczeÅ›niej niÅ¼ potrzeba;</li>
<li>umoÅ¼liwia programowanie z (potencjalnie) nieskoÅ„czonymi
strukturami,</li>
<li>daje peÅ‚nÄ… kompozycjonalnoÅ›Ä‡</li>
</ul></li>
<li>Bogaty system typÃ³w
<ul>
<li>polimorfizm, typy algebraiczne, klasy typÃ³w</li>
<li>interpreter/kompilator potrafi odtworzyÄ‡ typ dowolnego
wyraÅ¼enia.</li>
</ul></li>
</ul>
</div>

<div id="organizacja" class="title-slide slide section level1">
<h1>Organizacja</h1>

</div>
<div id="plan-wykÅ‚adu" class="title-slide slide section level2">
<h1>Plan wykÅ‚adu</h1>
<ol style="list-style-type: decimal">
<li>WstÄ™p</li>
<li>Typy</li>
<li>Klasy</li>
<li>Studium przypadku: liczby naturalne, listy</li>
<li>Real World Haskell: I/O, moduÅ‚y, cabal</li>
<li>Lenistwo, strumienie</li>
<li>WyÅ¼sze klasy Functor, Applicative,</li>
<li>Monady</li>
<li>Foldable/Traversable</li>
<li>Wnioskowanie o programach</li>
<li>Testowanie</li>
<li>Tour de force: soczewki (Costate Comonad Coalgebraâ€¦)</li>
</ol>
</div>

<div id="laboratorium" class="title-slide slide section level2">
<h1>Laboratorium</h1>
<p>Celem laboratorium jest przeÄ‡wiczenie koncepcji z wykÅ‚adu pod
kierunkiem prowadzÄ…cego,<br/> wyjaÅ›nienie niejasnoÅ›ci (oraz oczywiÅ›cie
eksperymentowanie).</p>
<p>CzÄ™Å›ciowo w formule â€œreverse classroomâ€:<br/> do wielu tematÃ³w jest
umyÅ›lnie wiÄ™cej zadaÅ„ niÅ¼ da siÄ™ zrobiÄ‡ w 90 minut;<br/> pozostaÅ‚e
naleÅ¼y zrobiÄ‡ we wÅ‚asnym zakresie,<br/> w razie problemÃ³w zwrÃ³ciÄ‡ siÄ™ do
prowadzÄ…cego na kolejnych zajÄ™ciach.</p>
<!--
Tym niemniej nie naleÅ¼y traktowaÄ‡ laboratorium tylko jak konsultacji;<br/>
nieobecnoÅ›Ä‡ utrudni zaliczenie przedmiotu.
-->
<p>W ramach laboratorium takÅ¼e wyjaÅ›nianie zadaÅ„ zaliczeniowych.</p>
</div>

<div id="materiaÅ‚y" class="title-slide slide section level2">
<h1>MateriaÅ‚y</h1>
<ul>
<li>MateriaÅ‚y na https://moodle.mimuw.edu.pl</li>
<li>Zadania oddajemy przez moodle (i omawiamy z prowadzÄ…cym)</li>
<li>Klucz dostÄ™pu <code>PF25g#0n</code> - gdzie n = numer grupy (np.
<code>PF25g#09</code>)</li>
<li>Strona zapasowa https://github.com/mbenke/pf25</li>
</ul>
</div>

<div id="zasady-zaliczania" class="title-slide slide section level2">
<h1>Zasady zaliczania</h1>
<ul>
<li>trzy zadania zaliczeniowe - tekstowa wizualizacja procesu ewaluacji:
<ul>
<li>T2-T3 (2-15.3) ustalone kombinatory (S, K, â€¦)</li>
<li>T4-T7 (16.3-12.4) kombinatory definiowane przez uÅ¼ytkownika
(pico-Haskell)</li>
<li>T8-T13 (13.4-7.6) toÅ¼ + dopasowanie wzorca</li>
</ul></li>
<li>zadania muszÄ… byÄ‡ oddane przez moodle w wyznaczonych terminach</li>
<li>ponadto rozmowa z prowadzÄ…cym na kolejnych zajÄ™ciach</li>
<li>egzamin pisemny w laboratorium</li>
</ul>
<p>Zadanie MUSI byÄ‡ rozwiÄ…zane samodzielnie. Wszelkie zapoÅ¼yczenia muszÄ…
byÄ‡ wyraÅºnie zaznaczone z podaniem ÅºrÃ³dÅ‚a. Dotyczy to takÅ¼e kodu
wygenerowanego/zasugerowanego przez narzÄ…dzia AI i pokrewne (VS Code,
Copilot, ChatGPT, Claude itp.)</p>
<p>Ponadto student musi umieÄ‡ objaÅ›niÄ‡ sposÃ³b dziaÅ‚ania kaÅ¼dego
fragmentu oddanego kodu.</p>
</div>


<div id="warunki-uzyskania-oceny-przed-sesjÄ…"
class="title-slide slide section level1">
<h1>Warunki uzyskania oceny przed sesjÄ…</h1>
<ul>
<li>wszystkie zadania oddane w terminie, &gt;= 70%</li>
<li>obecnoÅ›Ä‡ (&gt;80%) i aktywnoÅ›Ä‡ na zajÄ™ciach</li>
<li>egzamin ustny</li>
</ul>
</div>
<div id="punktacja" class="title-slide slide section level2">
<h1>Punktacja</h1>
<ul>
<li>Zadanie 1: 5 punktÃ³w; spÃ³Åºnienie do 48h 1p, do 7 dni 2p, potem 1p za
kazdy tydzieÅ„</li>
<li>Zadanie 2: 10p; spÃ³Åºnienie do 48h 1p; potem 2p za kaÅ¼dy rozpoczÄ™ty
tydzieÅ„;</li>
<li>Zadanie 3: 15p; spÃ³Åºnienie do 24h 1p; do 48h 2p; do 7 dni 3p;
powyÅ¼ej 5p</li>
<li>Egzamin 30p</li>
</ul>
</div>

</body>
</html>
